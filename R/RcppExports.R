# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Starting value to iterate (in lexicographical order) 
#' over all bit permutaions having l bits set to 1.
#' E.g.: start_bit_permutations(2) = 3 [=0..011].
#' @keywords internal
#' @noRd
NULL

#' Next value to iterate (in lexicographical order) over all bit 
#' permutaions having l bits set to 1.
#' Example sequence (2 bits): {0011, 0101, 0110, 1001, 1010, 1100}.
#' Source: https://stackoverflow.com/questions/1851134/generate-all-binary-strings-of-length-n-with-k-bits-set
#' @keywords internal
#' @noRd
NULL

#' Is index i_child a child of index i_parent?
#' ASSERT: i_child is of the form (i_parent XOR i_help),
#'         with i_help having exactly one non-zero bit
#' @keywords internal
#' @noRd
NULL

#' Get number of non-zero bits of a 32bit integer
#' Source: https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer
#' @keywords internal
#' @noRd
NULL

#' Does the combination comb of changepoints contain the changepoint k_ind?
#' @keywords internal
#' @noRd
NULL

#' Compute the Local cost terms of combination icomb (for RSS resp. sBIC).
#' Use pre-computed partial sum matrix sub_sums (see extract_sub) for speedup
#' @keywords internal
#' @noRd
NULL

#' where is leftmost one?
#' https://www.geeksforgeeks.org/find-significant-set-bit-number/
#' @keywords internal
#' @noRd
NULL

#' Get integer vector of changepoint indices,
#' based on bool-field representation of combinations.
#' E.g. for combination index 11 [=1011]: get_comb_ind(c(T,F,T,T))=11
#' @keywords internal
#' @noRd
get_comb_ind <- function(active) {
    .Call(`_breakfast_get_comb_ind`, active)
}

#' Helping function for algorithm 2: Pre-compute the partial sums
#' S_i = sum{j=k_i+1}^{k_{i+1}}x_i and the partial sums of squared
#' T_i = sum{j=k_i+1}^{k_{i+1}}x_i^2
#' between the (sorted) candidates k_i and k_{i+1} in cand.
#' Output: data frame with 4 columns k_i | k_{i+1} | S_i | T_i
#' @keywords internal
#' @noRd
extract_sub <- function(cand, x) {
    .Call(`_breakfast_extract_sub`, cand, x)
}

#' Algorithm II (Local change-point search with SC)
#' 
#' Input cand: =mathcal D, conflicting changepoints candidate set
#' Input sub_sums: Pre-computed partial sums, as obtained by extract_sub
#' Input strength: Exponent for penalty
#' Input log_penalty: log (or polynomial) penalty term?
#' Input n: Overall length of data
#' Input auc: =|mathcal C|, total number of currently active changepoints 
#'       (+candidates)
#' Input min_cost: Minimal RSS with all the candidates
#' 
#' Output sc: (Mx2) matrix (M=2^m with m=|cand|) containing RSS/cost and SC
#'         terms for all combinations within cand. Combinations are indexed
#'         by their implicit integer representation, i.e. sc[0,] corresponds
#'         to the empty set, sc[3,] to {k_1,k_2} [0..011], etc.
#'         Note: Row May be Inf, if combination was not visited in algorithm.
#' Output est_cpts: Integer Vector of estimated changepoints
#' Output final: Bool Vector indicating if combinations are final states
#' Output num_cpts: For debugging purposes
#' @keywords internal
#' @noRd
exhaust_sc <- function(cand, sub_sums, strength, log_penalty, n, auc, min_cost) {
    .Call(`_breakfast_exhaust_sc`, cand, sub_sums, strength, log_penalty, n, auc, min_cost)
}

#' @keywords internal
#' @noRd
call_not_r_wrapper <- function(x, intervals, method, contrast_type, parallel, augmented) {
    .Call(`_breakfast_call_not_r_wrapper`, x, intervals, method, contrast_type, parallel, augmented)
}

